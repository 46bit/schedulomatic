#!/usr/bin/env python

import os, sys, glob, argparse, csv, time

class DaySchedule:
  def __init__(self, date, start_time, end_time):
    self.date = date
    self.start_minutes = self.time_to_minutes(start_time)
    self.end_minutes = self.time_to_minutes(end_time)

    self.minute_duration = self.end_minutes - self.start_minutes
    self.time_slices = {}
    for i in xrange(self.minute_duration + 1):
      self.time_slices[i] = 1

  def add_event(self, start_time, end_time):
    start_minutes = self.time_to_relative_minutes(start_time)
    end_minutes = self.time_to_relative_minutes(end_time)
    for i in xrange(start_minutes, end_minutes + 1):
      self.time_slices[i] = 0

  def time_to_minutes(self, time):
    return time.tm_hour * 60 + time.tm_min

  def time_to_relative_minutes(self, time):
    return self.time_to_minutes(time) - self.start_minutes

  def relative_minutes_to_time(self, minutes):
    minutes += self.start_minutes
    hour = minutes / 60
    minute = minutes % 60
    return time.strptime(str(hour) + ':' + str(minute), '%H:%M')

  def find_space(self):
    spaces = []
    space_start = -1
    for i in xrange(self.minute_duration + 1):
      if self.time_slices[i] == 1:
        if space_start == -1:
          space_start = i
      else:
        if space_start != -1:
          spaces.append([space_start, i - 1])
          space_start = -1
    if space_start != -1:
      spaces.append([space_start, self.minute_duration])
    return spaces

  def find_space_times(self, minimum=30):
    space_times = []
    for space in self.find_space():
      if space[1] - space[0] < minimum:
        continue
      space_start_time = self.relative_minutes_to_time(space[0])
      space_end_time = self.relative_minutes_to_time(space[1])
      space_times.append([space_start_time, space_end_time])
    return space_times

def is_empty(v):
  return (v is None or len(v) == 0)

def main():
  argparser = argparse.ArgumentParser(description='Find gaps in timetable CSVs')
  argparser.add_argument('timetable_directory', type=str,
                         help='Directory containing timetable CSVs.')
  args = argparser.parse_args()

  date_format = '%d/%m/%Y'
  time_format = '%H:%M'
  csv_time_format = '%H:%M:%S'

  day_start_time = time.strptime('08:50', time_format)
  day_end_time = time.strptime('19:40', time_format)

  if not os.path.isdir(args.timetable_directory):
    print "Directory {} does not exist.".format(args.timetable_directory)
    return 2

  daily_schedules = {}

  os.chdir(args.timetable_directory)
  for f in glob.glob("*.csv"):
    with open(f, 'rbU') as csvfile:
      csvreader = csv.DictReader(csvfile, skipinitialspace=True)
      for row in csvreader:
        start_date = row['Start Date']
        start_time = row['Start Time']
        end_time = row['End Time']
        if is_empty(start_date) or is_empty(start_time) or is_empty(end_time) or start_date != row['End Date']:
          continue

        start_date = time.strptime(start_date, date_format)
        start_time = time.strptime(start_time, csv_time_format)
        end_time = time.strptime(end_time, csv_time_format)

        if start_date not in daily_schedules:
          daily_schedules[start_date] = DaySchedule(start_date, day_start_time, day_end_time)
        daily_schedules[start_date].add_event(start_time, end_time)

  for date in daily_schedules:
    day_space_times = daily_schedules[date].find_space_times()
    print "On", time.strftime(date_format, date), "free times are:"
    for st in day_space_times:
      print "-", time.strftime(time_format, st[0]) + "-" + time.strftime(time_format, st[1])

if __name__ == "__main__":
  sys.exit(main())
