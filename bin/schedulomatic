#!/usr/bin/env python

import os, sys, glob, argparse, csv, time

class DayTimeUsage:
  def __init__(self, date, start_time, end_time):
    self.date = date
    self.start_minutes = self.time_to_minutes(start_time)
    self.end_minutes = self.time_to_minutes(end_time)

    self.minute_duration = self.end_minutes - self.start_minutes
    self.time_slices = {}
    for i in xrange(self.minute_duration + 1):
      self.time_slices[i] = 1

  def add_event(self, start_time, end_time):
    start_minutes = self.time_to_relative_minutes(start_time)
    end_minutes = self.time_to_relative_minutes(end_time)
    for i in xrange(start_minutes, end_minutes + 1):
      self.time_slices[i] = 0

  def time_to_minutes(self, time):
    return time.tm_hour * 60 + time.tm_min

  def time_to_relative_minutes(self, time):
    return self.time_to_minutes(time) - self.start_minutes

  def relative_minutes_to_time(self, minutes):
    minutes += self.start_minutes
    hour = minutes / 60
    minute = minutes % 60
    return time.strptime(str(hour) + ':' + str(minute), '%H:%M')

  def find_space(self):
    spaces = []
    space_start = -1
    for i in xrange(self.minute_duration + 1):
      if self.time_slices[i] == 1:
        if space_start == -1:
          space_start = i
      else:
        if space_start != -1:
          spaces.append([space_start, i - 1])
          space_start = -1
    if space_start != -1:
      spaces.append([space_start, self.minute_duration])
    return spaces

  def find_space_times(self, minimum=30):
    space_times = []
    for space in self.find_space():
      if space[1] - space[0] < minimum:
        continue
      space_start_time = self.relative_minutes_to_time(space[0])
      space_end_time = self.relative_minutes_to_time(space[1])
      space_times.append([space_start_time, space_end_time])
    return space_times

class Schedulomatic:
  def __init__(self, timetable_directory, day_start_time, day_end_time):
    self.timetable_directory = timetable_directory
    self.day_start_time = day_start_time
    self.day_end_time = day_end_time

    self.daily_time_usages = None
    self.daily_free_time = None

  def find_daily_time_usages(self):
    csv_date_format = '%d/%m/%Y'
    csv_time_format = '%H:%M:%S'

    if not os.path.isdir(self.timetable_directory):
      raise "Timetable directory not found!"

    self.daily_time_usages = {}

    os.chdir(self.timetable_directory)
    for f in glob.glob("*.csv"):
      with open(f, 'rbU') as csvfile:
        csvreader = csv.DictReader(csvfile, skipinitialspace=True)
        for row in csvreader:
          start_date = row['Start Date']
          start_time = row['Start Time']
          end_time = row['End Time']
          if self.is_empty(start_date) or self.is_empty(start_time) or self.is_empty(end_time) or start_date != row['End Date']:
            continue

          start_date = time.strptime(start_date, csv_date_format)
          start_time = time.strptime(start_time, csv_time_format)
          end_time = time.strptime(end_time, csv_time_format)

          if start_date not in self.daily_time_usages:
            dtu = DayTimeUsage(start_date, self.day_start_time, self.day_end_time)
            self.daily_time_usages[start_date] = dtu
          self.daily_time_usages[start_date].add_event(start_time, end_time)

  def find_daily_free_time(self):
    if self.daily_time_usages is None:
      self.find_daily_time_usages()
    self.daily_free_time = {}
    for date in sorted(self.daily_time_usages):
      self.daily_free_time[date] = self.daily_time_usages[date].find_space_times()

  def is_empty(self, v):
    return (v is None or len(v) == 0)

def main():
  argparser = argparse.ArgumentParser(description='Find gaps in timetable CSVs')
  argparser.add_argument('timetable_directory', type=str,
                         help='Directory containing timetable CSVs.')
  args = argparser.parse_args()

  date_format = '%d/%m/%Y'
  time_format = '%H:%M'

  day_start_time = time.strptime('08:50', time_format)
  day_end_time = time.strptime('19:40', time_format)

  if not os.path.isdir(args.timetable_directory):
    print "Directory {} does not exist.".format(args.timetable_directory)
    return 2

  sched = Schedulomatic(args.timetable_directory, day_start_time, day_end_time)
  sched.find_daily_free_time()

  for date in sorted(sched.daily_free_time):
    print "On", time.strftime(date_format, date), "free times are:"
    for free_time in sched.daily_free_time[date]:
      print "-", time.strftime(time_format, free_time[0]) + "-" + time.strftime(time_format, free_time[1])

if __name__ == "__main__":
  sys.exit(main())
